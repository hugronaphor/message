<?php

/**
 * @file
 * Main module file.
 */
/**
 * Status constant for read messages.
 */
define('UMSG_READ', 0);
/**
 * Status constant for unread messages.
 */
define('UMSG_UNREAD', 1);

/**
 * Fake function callback name.
 */
define('UMSG_FAKE_CALLBACK', 'umsg_fake_function');

// Include Query file.
require_once 'api/umsgController.php';

/**
 * Implements hook_permission().
 */
function umsg_permission() {
  return array(
    'administer umsg settings' => array(
      'title' => t('Administer umsg'),
      'description' => t('Perform maintenance tasks for umsg'),
    ),
    'read umsg' => array(
      'title' => t('Read own user messages'),
      'description' => t('Read own user messages'),
    ),
    'read all user messages' => array(
      'title' => t('Read all user messages'),
      'description' => t('Includes messages of other users'),
    ),
    'write umsg' => array(
      'title' => t('Write new user messages'),
      'description' => t('Write new user messages'),
    ),
    'delete umsg' => array(
      'title' => t('Delete own user messages'),
      'description' => t('Delete user messages'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function umsg_menu() {

  $items['messages'] = array(
    'title' => 'Messages',
    'title callback' => 'umsg_title_callback',
    'page callback' => 'umsg_list_page',
    'page arguments' => array('list'),
    'file' => 'umsg.pages.inc',
    'access callback' => 'umsg_user_access',
    'type' => MENU_NORMAL_ITEM,
    'menu_name' => 'user-menu',
  );
  $items['messages/list'] = array(
    'title' => 'Messages',
    'page callback' => 'umsg_list_page',
    'page arguments' => array('list'),
    'file' => 'umsg.pages.inc',
    'access callback' => 'umsg_user_access',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['messages/sent'] = array(
    'title' => 'Sent',
    'page callback' => 'umsg_list_page',
    'page arguments' => array('list_sent'),
    'file' => 'umsg.pages.inc',
    'access callback' => 'umsg_user_access',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['messages/trash'] = array(
    'title' => 'Trash',
    'page callback' => 'umsg_list_page',
    'page arguments' => array('list_trash'),
    'file' => 'umsg.pages.inc',
    'access callback' => 'umsg_user_access',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['messages/view/%umsg_thread'] = array(
    //'load arguments'   => array(NULL, NULL),
    'title'            => 'Title of thread?',
    'page callback'    => 'umsg_view',
    'page arguments'   => array(2),
    'file'             => 'umsg.pages.inc',
//    'access callback'  => 'umsg_user_access',
//    'access arguments' => array('read umsg'),
  );
//  $items['messages/delete/%umsg_thread/%umsg_message'] = array(
//    'title'            => 'Delete message',
//    'page callback'    => 'drupal_get_form',
//    'page arguments'   => array('umsg_delete', 2, 3),
//    'file'             => 'umsg.pages.inc',
//    'access callback'  => 'umsg_user_access',
//    'access arguments' => array('delete umsg'),u
//  );
  $items['messages/new'] = array(
    'title' => t('Compose a new'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('umsg_new', 2, 3, NULL),
    'file' => 'umsg.pages.inc',
    'access callback' => 'umsg_user_access',
    'access arguments' => array('write umsg'),
    'type' => MENU_NORMAL_ITEM,
  );
  // Auto-completes available user names & removes duplicates.
  $items['messages/autocomplete'] = array(
    'page callback' => 'umsg_autocomplete',
    'file' => 'umsg.pages.inc',
    'access callback' => 'umsg_user_access',
    'access arguments' => array('write umsg'),
    'type' => MENU_CALLBACK,
  );
  // Admin pages.
  $items['admin/config/messaging/umsg'] = array(
    'title' => 'User message settings',
    'description' => 'Configure user messaging settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('umsg_admin_settings'),
    'file' => 'umsg.admin.inc',
    'access arguments' => array('administer umsg settings'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/messaging/umsg/settings'] = array(
    'title' => 'User message settings',
    'description' => 'Configure user messaging settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('umsg_admin_settings'),
    'file' => 'umsg.admin.inc',
    'access arguments' => array('administer umsg settings'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  return $items;
}

function umsg_preprocess_html(&$vars) {
  
}

/**
 * Wrapper for user_access.
 *
 * Never allows anonymous user access.
 *
 * @param $permission
 *   Permission string, defaults to read umsg
 *
 * @return
 *   TRUE if user has access, FALSE if not
 *
 * @ingroup api
 */
function umsg_user_access($permission = 'read umsg', $account = NULL) {
  if ($account === NULL) {
    global $user;
    $account = $user;
  }

  // Disallow anonymous access, regardless of permissions
  if (!$account->uid) {
    return FALSE;
  }

  if (!user_access($permission, $account)) {
    return FALSE;
  }
  return TRUE;
}

function umsg_title_callback($scope = NULL) {

  $count = umsg_unread_count();

  if ($count > 0) {
    if ($scope == 'nav') {
      return t('Inbox %count', array('%count' => $count));
    }
    else {
      return t('Inbox (@count)', array('@count' => $count));
    }
  }
  return t('Inbox');
}

/**
 * Return number of unread messages for an account.
 *
 * @param $account
 *   Specify the user for which the unread count should be loaded.
 *
 * @ingroup api
 */
function umsg_unread_count($scope = 'index') {
  global $user;
  $account = $user;

  $counts = &drupal_static(__FUNCTION__ . $account->uid . $scope);

  if (!isset($counts)) {
    // Count Inbox/Archived unreaded threads.
    $umsg = new umsgController();
    $counts = $umsg->countUnread($account, $scope);
    $counts = !empty($counts) ? $counts : t('empty');
  }

  return $counts;
}

/**
 * Formats all rows (#options) in the message tableselect thread list.
 *
 * Uses @link theming theme patterns @endlink to theme single fields.
 *
 * @param $thread
 *   Array with the row data returned by the database.
 * @return
 *   Row definition for use with theme('table')
 */
function _umsg_list_thread($tableselect) {
  foreach ($tableselect['#options'] as $id => $thread) {
    $row = array();
    if (!empty($thread['is_new'])) {
      // Set the css class in the tr tag.
      $row['#attributes']['class'][] = 'umsg-unread';
    }

    foreach ($thread as $key => $data) {
      // First, try to load a specific theme for that field, if not present, use the default.
      if ($return = theme('umsg_list_field__' . $key, array('thread' => $thread))) {
        $row[$key] = $return;
      }
    }

    $row[$key] = $return;
    $tableselect['#options'][$id] = $row;
  }
  return $tableselect;
}

function umsg_theme() {
  $templates = array(
    // Define pattern for header/field templates. The theme system will register all
    // theme functions that start with the defined pattern.
    'umsg_list_header' => array(
      'file' => 'umsg.theme.inc',
      'path' => drupal_get_path('module', 'umsg'),
      'pattern' => 'umsg_list_header__',
      'variables' => array(),
    ),
    'umsg_list_field' => array(
      'file' => 'umsg.theme.inc',
      'path' => drupal_get_path('module', 'umsg'),
      'pattern' => 'umsg_list_field__',
      'variables' => array('thread' => array()),
    ),
    'umsg_username' => array(
      'file' => 'umsg.theme.inc',
      'path' => drupal_get_path('module', 'umsg'),
      'variables' => array('recipient' => NULL, 'options' => array()),
    ),
  );
  // Include the theme file to load the theme suggestions.
  module_load_include('inc', 'umsg', 'umsg.theme');
  $templates += drupal_find_theme_functions($templates, array('theme'));
  return $templates;
}

/**
 * Formats a timestamp according to the defines rules.
 *
 * Examples/Rules:
 *
 * Current hour: 25 min ago
 * Current day (but not within the hour): 10:30 am
 * Current year (but not on the same day): Nov 25
 * Prior years (not the current year): 11/25/08
 *
 * @param $timestamp
 *   UNIX Timestamp.
 *
 * @return
 *   The formatted date.
 */
function umsg_format_date($timestamp) {
  if ($timestamp > ((int) (REQUEST_TIME / 3600)) * 3600) {
    return t('@interval ago', array('@interval' => format_interval(abs(REQUEST_TIME - $timestamp), 1)));
  }
  if ($timestamp > ((int) (REQUEST_TIME / 86400)) * 86400) {
    return format_date($timestamp, 'umsg_current_day');
  }
  if ($timestamp > mktime(0, 0, 0, 1, 0, date('Y'))) {
    return format_date($timestamp, 'umsg_current_year');
  }
  return format_date($timestamp, 'umsg_years');
}

/**
 * Implements hook_block_info().
 */
function umsg_block_info() {
  $blocks['umsg_msg_navigation'] = array(
    'info' => t('Main Message navigation'),
    'cache' => DRUPAL_CACHE_PER_USER,
  );

  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function umsg_block_configure($delta) {
  
}

/**
 * Implements hook_block_save().
 */
function umsg_block_save($delta, $edit = array()) {
  
}

/**
 * Implements hook_block_view().
 */
function umsg_block_view($delta) {
  $block = array();
  switch ($delta) {
    case 'umsg_msg_navigation':
      //$block['subject'] = t('Din aceeasi categorie');
      $block['content'] = _umsg_get_main_navigation();
      break;
  }
  return $block;
}

function _umsg_get_main_navigation() {
  $block = array();

  $links = array();
  if (umsg_user_access('write umsg')) {
    $links[] = l(t('Compose message'), 'messages/new');
  }
  if (umsg_user_access('read umsg') || umsg_user_access('read all user messages')) {
    $links[] = l(umsg_title_callback('nav'), 'messages/list', array('html' => TRUE));
    $links[] = l(t('Sent'), 'messages/sent');
    $links[] = l(t('Trash %trash_count', array('%trash_count' => umsg_unread_count('trash'))), 'messages/trash', array('html' => TRUE));
  }

  if (count($links)) {
    $block = array(
      //'subject' => t(''),
      'content' => theme('item_list', array('items' => $links)),
    );
  }
  return $block;
}

/**
 * Returns a table header definition based on the submitted keys.
 *
 * Uses @link theming theme patterns @endlink to theme single headers.
 *
 * @param $has_posts
 *   TRUE when there is at least one row. Decides if the select all checkbox should be displayed.
 * @param $keys
 *   Array with the keys which are present in the query/should be displayed.
 * @return
 *   Array with header definitions for tablesort_sql and theme('table').
 */
function _umsg_list_headers($keys) {

  // theme() doesn't include the theme file for patterns, we need to do it manually.
  include_once drupal_get_path('module', 'umsg') . '/umsg.theme.inc';

  $header = array();
  foreach ($keys as $key) {
    // First, try to load a specific theme for that header, if not present, use the default.
    if ($return = theme('umsg_list_header__' . $key)) {
      // The default theme returns nothing, only store the value if we have something.
      $header[$key] = $return;
    }
  }
  // uasort($header, 'element_sort');
  // Remove weight column or it will show up in the markup.
  foreach ($header as $key => $element) {
    if (isset($header[$key]['#weight'])) {
      unset($header[$key]['#weight']);
    }
  }
  return $header;
}

/**
 * Get an array of available thread operations.
 */
function umsg_thread_operations($type) {
  $operations['update'] = array(
    'label' => t('Update'),
    'callback' => 'umsg_fake_function',
    'button' => TRUE,
  );

  if (umsg_user_access('delete umsg')) {
    // Detect which delete action to perform.
    $delete_type = ($type == 'list_trash') ? 0 : 1;
    $operations['delete'] = array(
      'label' => t('Delete'),
      'callback' => 'umsg_thread_delete',
      // Delete or archive (depending on page).
      'callback arguments' => array('delete_action' => $delete_type),
      'button' => TRUE,
    );
  }

  return $operations;
}

/**
 * Execute an operation on a number of threads.
 *
 * @param $operation
 *   The operation that should be executed.
 * @param $threads
 *   An array of thread ids. The array is filtered before used, a checkboxes
 *   array can be directly passed to it.
 */
function umsg_operation_execute($operation, $threads, $account = NULL) {

  // Filter out unchecked threads, this gives us an array of "checked" threads.
  $threads = array_filter($threads);
  if (empty($threads)) {
    // Do not execute anything if there are no checked threads.
    drupal_set_message(t('You must first select one (or more) messages before you can take that action.'), 'warning');
    return FALSE;
  }
  // Add in callback arguments if present.
  if (isset($operation['callback arguments'])) {
    $args = array_merge(array($threads), $operation['callback arguments']);
  }
  else {
    $args = array($threads);
  }

  // Add the user object to the arguments.
  if ($account) {
    $args[] = $account;
  }

  // Execute the chosen action and pass the defined arguments.
  call_user_func_array($operation['callback'], $args);

  if (!empty($operation['success message'])) {
    drupal_set_message($operation['success message']);
  }

  return TRUE;
}

/**
 * Delete or archive one or multiple threads.
 *
 * @param $threads
 *   Array with thread id's or a single thread id.
 * @param $delete
 *   Indicates if the threads should be deleted or restored. 1 => delete, 0 => restore.
 * @param $account
 *   User account for which the delete action should be carried out - Set to NULL to delete for all users.
 */
function umsg_thread_delete($threads, $delete, $account = NULL) {
  if (!is_array($threads)) {
    $threads = array($threads);
  }
  if (empty($account)) {
    global $user;
    $account = clone $user;
  }

  // Load all messages of those threads including the deleted.
  $umsg = new umsgController();
  $query = $umsg->load('thread_messages', $threads);

  // Delete each message.
  foreach ($query->execute() as $row) {
    // $delete -> [1 => archive, 0 => delete]
    $umsg->changeMsg($row->mid, $delete, $account);
  }

  if ($delete) {
    drupal_set_message(format_plural(count($threads), 'Archived 1 thread.', 'Archived @count threads.'));
  }
  else {
    drupal_set_message(format_plural(count($threads), 'Deleted 1 thread.', 'Deleted @count threads.'));
  }
}

/**
 * Generate array of user objects based on a string.
 *
 *
 * @param $userstring
 *   A string with user id, for example 1,2,4. Returned by the list query.
 *
 * @return
 *   Array with user objects.
 */
function _umsg_generate_user_array($string, $slice = NULL) {
  // Convert user uid list (uid1,uid2,uid3) into an array. If $slice is not NULL
  // pass that as argument to array_slice(). For example, -4 will only load the
  // last four users.
  // This is done to avoid loading user objects that are not displayed, for
  // obvious performance reasons.
  $users = explode(',', $string);
  if (!is_null($slice)) {
    $users = array_slice($users, $slice);
  }
  $participants = array();
  foreach ($users as $uid) {
    // If it is an integer, it is a user id.
    if ((int) $uid > 0) {
      $user_ids = privatemsg_user_load_multiple(array($uid));
      if ($account = array_shift($user_ids)) {
        $participants[$account->uid] = $account;
      }
    }
    elseif (strpos($uid, '_') !== FALSE) {
      list($type, $id) = explode('_', $uid);
      $type_info = privatemsg_recipient_get_type($type);
      if ($type_info && isset($type_info['load']) && is_callable($type_info['load'])) {
        $temp_load = $type_info['load'](array($id));
        if ($participant = array_shift($temp_load)) {
          $participants[$account->uid] = $participant;
        }
      }
    }
  }
  return $participants;
}

/**
 * Implements callback_recipient_autocomplete().
 */
function umsg_user_autocomplete($fragment) {
  global $user;
  // First, load all possible uids.
  $uids = db_select('users', 'u')
          ->fields('u', array('uid'))
          ->condition('u.name', $fragment . '%', 'LIKE')
          ->condition('u.status', 0, '<>')
          // exclude sef-user.
          ->condition('u.uid', $user->uid, '<>')
          ->orderBy('u.name', 'ASC')
          ->range(0, 10)
          ->execute()
          ->fetchCol();
  // Load the corresponding users, make sure to not load any duplicates.
  $accounts = user_load_multiple(array_unique($uids));

  // Return them in an array.
  $suggestions = array();
  foreach ($accounts as $account) {
    $account->type = 'user';
    $account->recipient = $account->uid;
    $suggestions[$account->uid] = $account;
  }

  return $suggestions;
}

/**
 * Format a single participant.
 *
 * @param $participant
 *   The participant object to format.
 *
 * @ingroup types.
 */
function umsg_recipient_format($recipient, $options = array()) {

  return theme('umsg_username', array('recipient' => $recipient, 'options' => $options));

//  if (!isset($recipient->type)) {
//    $recipient->type = 'user';
//    $recipient->recipient = $recipient->uid;
//  }
//  $type = privatemsg_recipient_get_type($recipient->type);
//  if (isset($type['format'])) {
//    return theme('umsg_username', array('recipient' => $recipient, 'options' => $options));
//  }
//  return NULL;
}

function _umsg_validate_message(&$message, $form = FALSE) {
  $messages = array('error' => array(), 'warning' => array());
  if (!(umsg_user_access('write umsg', $message->author))) {
    // no need to do further checks in this case...
    if ($form) {
      form_set_error('author', t('You are not allowed to write messages.'));
      return array(
        'success' => FALSE,
        'messages' => $messages,
      );
    }
    else {
      $messages['error'][] = t('@user is not allowed to write messages.', array('@user' => $message->author));
      return array(
        'success' => FALSE,
        'messages' => $messages,
      );
    }
  }

  // Don't allow replies without a body.
  if (!empty($message->thread_id) && ($message->body === NULL || $message->body === '')) {
    if ($form) {
      form_set_error('body', t('You must include a message in your reply.'));
    }
    else {
      $messages['error'][] = t('A message must be included in your reply.');
    }
  }

  if (empty($message->recipients)) {
    if ($form) {
      form_set_error('recipient', t('You must include a valid recipient.'));
    }
    else {
      $messages['error'][] = t('A valid recipient must be included with the message.');
    }
  }

  // Check if there are errors in $messages or if $form is TRUE, there are form errors.
  $success = empty($messages['error']) || ($form && count((array) form_get_errors()) > 0);
  return array(
    'success' => $success,
    'messages' => $messages,
  );
}
